// helper function to chop array in chunks of given size
Array.prototype.chop = function (size) {
    //temp array
    const temp = [...this];
  
    //if the size is not defined
    if (!size) {
      return temp;
    }
  
    //output
    const output = [];
    let i = 0;
  
    //iterate the array
    while (i < temp.length) {
      //slice the sub-array of a given size
      //and push them in output array
      output.push(temp.slice(i, i + size));
      i = i + size;
    }
  
    return output;
  };
  
  const mapLimit = (arr, limit, fn) => {
    // return a new promise
    return new Promise((resolve, reject) => {
      // chop the input array into the subarray of limit
      // [[1, 2, 3], [1, 2, 3]]
      let chopped = arr.chop(limit);
      
      // for all the subarrays of chopped
      // run it in series
      // that is one after another
      // initially it will take an empty array to resolve
      // merge the output of the subarray and pass it on to the next
      const final = chopped.reduce((a, b) => {
        return a.then((val) => {
          // run the sub-array values in parallel
          // pass each input to the iteratee function
          // and store their outputs
          // after all the tasks are executed
          // merge the output with the previous one and resolve
          return new Promise((resolve, reject) => {
  
            const results = [];
            let tasksCompleted = 0;
            b.forEach((e) => {
              fn(e, (error, value) => {
                if(error){
                  reject(error);
                }else{
                  results.push(value);
                  tasksCompleted++;
                  if (tasksCompleted >= b.length) {
                    resolve([...val, ...results]);
                  }
                }
              });
            });
          });
  
        });
      }, Promise.resolve([]));
  
      // based on final promise state 
      // invoke the final promise.
      final
        .then((result) => {
          resolve(result);
        })
        .catch((e) => {
          reject(e);
        });
    });
  };